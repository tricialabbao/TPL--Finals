<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Java Compiler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #52616B 0%, #2C3E50 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
            max-width: 1300px;
            width: 100%;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            color: #52616B;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        /* FLEX WRAPPER FOR BUTTONS + TEXT AREAS */
        .layout-wrapper {
            display: flex;
            gap: 25px;
        }

        /* BUTTONS GO TO LEFT SIDE */
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: flex-start;
            width: 180px;
        }

        .panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #e9ecef;
            margin-bottom: 25px;
        }

        .panel h2 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        textarea {
            width: 100%;
            min-height: 300px;
            padding: 15px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s;
        }

        #codeArea {
            background: #fff;
        }

        /* üî• RESULT AREA SMALL LIKE SEARCH BAR */
        #resultArea {
            background: #f8f9fa;
            min-height: 45px;
            max-height: 60px;
            resize: none;
            padding: 12px;
            font-size: 14px;
        }

        button {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: 0.3s;
            color: white;
            width: 100%;
        }

        #openFileBtn { background: #2D3748; }
        #lexicalBtn { background: #4A5568; }
        #syntaxBtn { background: #718096; }
        #semanticBtn { background: #A0AEC0; color: black; }
        #clearBtn { background: #CBD5E0; color: black; }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .file-input { display: none; }

    </style>
</head>
<body>
    <div class="container">
        <h1> Mini Java Compiler</h1>
        <p class="subtitle">Front-end Compiler</p>

        <div class="layout-wrapper">
            
            <!-- ‚úÖ LEFT SIDE BUTTONS -->
            <div class="button-group">
                <input type="file" id="fileInput" class="file-input" accept=".txt,.java">
                <button id="openFileBtn">üìÅ Open File</button>
                <button id="lexicalBtn" disabled> Lexical Analysis</button>
                <button id="syntaxBtn" disabled> Syntax Analysis</button>
                <button id="semanticBtn" disabled> Semantic Analysis</button>
                <button id="clearBtn" disabled> Clear</button>
            </div>

            <!-- ‚úÖ RIGHT SIDE (RESULT ON TOP, CODE BELOW) -->
            <div style="flex: 1;">

                <!-- üîº RESULT AREA FIRST -->
                <div class="panel">
                    <h2>Result Text Area</h2>
                    <textarea id="resultArea" readonly placeholder="Analysis results will appear here..."></textarea>
                </div>

                <!-- üîΩ CODE AREA SECOND -->
                <div class="panel">
                    <h2>Code Text Area</h2>
                    <textarea id="codeArea" placeholder="Open a file or paste your Java variable declarations here..." readonly></textarea>
                </div>

            </div>

        </div>
    </div>

    <script>
        let appState = {
            fileLoaded: false,
            lexicalPassed: false,
            syntaxPassed: false,
            semanticPassed: false,
            tokens: [],
            variables: {}
        };

        const codeArea = document.getElementById('codeArea');
        const resultArea = document.getElementById('resultArea');
        const fileInput = document.getElementById('fileInput');
        const openFileBtn = document.getElementById('openFileBtn');
        const lexicalBtn = document.getElementById('lexicalBtn');
        const syntaxBtn = document.getElementById('syntaxBtn');
        const semanticBtn = document.getElementById('semanticBtn');
        const clearBtn = document.getElementById('clearBtn');

        openFileBtn.addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    codeArea.value = event.target.result;
                    appState.fileLoaded = true;
                    updateButtonStates();
                    resultArea.value = '‚úÖ File loaded successfully!\n\nClick "Lexical Analysis" to begin.';
                };
                reader.readAsText(file);
            }
        });

        lexicalBtn.addEventListener('click', () => performLexicalAnalysis());

        function performLexicalAnalysis() {
            const code = codeArea.value.trim();
            if (!code) {
                resultArea.value = '‚ùå ERROR: No code to analyze!';
                return;
            }

            resultArea.value = 'üîç Performing Lexical Analysis...\n\n';
            
            const lines = code.split('\n');
            let tokens = [];
            let errors = [];

            const tokenPatterns = {
                KEYWORD: /^(int|double|float|char|boolean|byte|short|long|String)$/,
                IDENTIFIER: /^[a-zA-Z_][a-zA-Z0-9_]*$/,
                NUMBER: /^-?\d+(\.\d+)?$/,
                STRING: /^"[^"]*"$/,
                CHAR: /^'.'$/,
                ASSIGNMENT: /^=$/,
                SEMICOLON: /^;$/
            };

            lines.forEach((line, lineNum) => {
                line = line.trim();
                if (!line) return;

                const lineTokens = line.split(/(\s+|=|;)/).filter(t => t.trim());

                lineTokens.forEach(token => {
                    let type = null;
                    for (let [t, p] of Object.entries(tokenPatterns)) {
                        if (p.test(token)) {
                            type = t;
                            break;
                        }
                    }
                    if (type) {
                        tokens.push({ type, value: token, line: lineNum + 1 });
                    } else {
                        errors.push(`Line ${lineNum + 1}: Invalid token '${token}'`);
                    }
                });
            });

            if (errors.length) {
                resultArea.value += '‚ùå LEXICAL ANALYSIS FAILED!\n\n' + errors.join("\n");
                appState.lexicalPassed = false;
            } else {
                resultArea.value += '‚úÖ LEXICAL ANALYSIS PASSED!';
                appState.lexicalPassed = true;
                appState.tokens = tokens;
            }

            updateButtonStates();
        }

        syntaxBtn.addEventListener('click', () => performSyntaxAnalysis());

        function performSyntaxAnalysis() {
            resultArea.value = 'üìã Performing Syntax Analysis...\n\n';
            
            const code = codeArea.value.trim();
            const lines = code.split('\n').filter(l => l.trim());
            let errors = [];

            lines.forEach((line, lineNum) => {
                line = line.trim();
                if (!line.endsWith(';')) {
                    errors.push(`Line ${lineNum + 1}: Missing semicolon`);
                    return;
                }

                const clean = line.slice(0, -1).trim();
                const pattern = /^(int|double|float|char|boolean|byte|short|long|String)\s+[a-zA-Z_][a-zA-Z0-9_]*\s*=\s*(.+)$/;

                if (!pattern.test(clean)) {
                    errors.push(`Line ${lineNum + 1}: Invalid declaration syntax`);
                }
            });

            if (errors.length) {
                resultArea.value += '‚ùå SYNTAX FAILED!\n\n' + errors.join("\n");
                appState.syntaxPassed = false;
            } else {
                resultArea.value += '‚úÖ SYNTAX PASSED!';
                appState.syntaxPassed = true;
            }

            updateButtonStates();
        }

        semanticBtn.addEventListener('click', () => performSemanticAnalysis());

        function performSemanticAnalysis() {
            resultArea.value = 'üîç Performing Semantic Analysis...\n\n';
            
            const code = codeArea.value.trim();
            const lines = code.split('\n').filter(l => l.trim());
            let errors = [];
            let vars = {};

            lines.forEach((line, lineNum) => {
                const clean = line.replace(';', '').trim();
                const match = clean.match(/^(int|double|float|char|boolean|byte|short|long|String)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(.+)$/);
                
                if (!match) return;

                const [, type, name, value] = match;

                if (vars[name]) {
                    errors.push(`Line ${lineNum + 1}: '${name}' already declared.`);
                    return;
                }

                const v = value.trim();

                const checks = {
                    int: /^-?\d+$/,
                    byte: /^-?\d+$/,
                    short: /^-?\d+$/,
                    long: /^-?\d+$/,
                    double: /^-?\d+(\.\d+)?$/,
                    float: /^-?\d+(\.\d+)?$/,
                    char: /^'.'$/,
                    boolean: /^(true|false)$/,
                    String: /^"[^"]*"$/,
                };

                if (!checks[type].test(v)) {
                    errors.push(`Line ${lineNum + 1}: Invalid value '${v}' for type '${type}'`);
                } else {
                    vars[name] = { type, value: v };
                }
            });

            if (errors.length) {
                resultArea.value += '‚ùå SEMANTIC FAILED!\n\n' + errors.join("\n");
                appState.semanticPassed = false;
            } else {
                resultArea.value += '‚úÖ SEMANTIC PASSED!';
                appState.semanticPassed = true;
                appState.variables = vars;
            }

            updateButtonStates();
        }

        clearBtn.addEventListener('click', resetApp);

        function resetApp() {
            codeArea.value = '';
            resultArea.value = '';
            fileInput.value = '';
            appState = {
                fileLoaded: false,
                lexicalPassed: false,
                syntaxPassed: false,
                semanticPassed: false,
                tokens: [],
                variables: {}
            };
            updateButtonStates();
        }

        function updateButtonStates() {
            lexicalBtn.disabled = !appState.fileLoaded || appState.lexicalPassed;
            syntaxBtn.disabled = !appState.lexicalPassed || appState.syntaxPassed;
            semanticBtn.disabled = !appState.syntaxPassed || appState.semanticPassed;
            clearBtn.disabled = false;
        }

        updateButtonStates();
    </script>

</body>
</html>
